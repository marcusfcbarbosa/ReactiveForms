Devido ao curso
ng --version
Obs: Versao atual do node 12
versao atual do angular cli 8.3.8



1- Criando um componente que sera um formulario de cadastro
ng g c demos/reactiveForms/cadastro
---------------------------------------------------------------------------------------------------------
2-Adicione o Module ReactiveForms no app.module (ou no modulo principal)
 import { FormsModule,ReactiveFormsModule }   from '@angular/forms';

  imports: [
    BrowserModule,
    FormsModule,
    ReactiveFormsModule, <==========Esse aqui
    [RouterModule.forRoot(rootRouterConfig, { useHash: false})]
  ],
  ---------------------------------------------------------------------------------------------------------
  3- Criar um link no menu de component
  menu.component.html
<li class="nav-item">
            <a class="nav-link"  [routerLink]="['/cadastro']">Cadastro</a>
</li>
e no app.router inserir uma nova rota

    { path: 'cadastro', component: CadastroComponent }
  ---------------------------------------------------------------------------------------------------------
  4- Colando um template de HTML pronto do formulario<div class="container main-container">
    <h4>Demo Cadastro</h4>
    <hr />
    <form novalidate (ngSubmit)="adicionarUsuario()" [formGroup]="cadastroForm">
        <div class="form-horizontal">

            <div class="form-group">
                <label class="col-md-2 control-label" for="nome">Nome Completo</label>
                <div class="col-md-10">
                    <input class="form-control" id="nome" type="text" placeholder="Nome (requerido)" formControlName="nome" [ngClass]="{'is-invalid': displayMessage.nome }" />
                    <span class="text-danger" *ngIf="displayMessage.nome">
                        <p [innerHTML]="displayMessage.nome"></p>
                    </span>
                </div>
            </div>

            <div class="form-group">
                <label class="col-md-2 control-label">CPF</label>
                <div class="col-md-10">
                    <input class="form-control" id="cpf" type="text" placeholder="CPF (requerido)" formControlName="cpf" cpf [textMask]="{mask: MASKS.cpf.textMask}" [ngClass]="{'is-invalid': displayMessage.cpf }" />

                    <span class="text-danger" *ngIf="displayMessage.cpf">
                        <p [innerHTML]="displayMessage.cpf"></p>
                    </span>
                </div>
            </div>

            <div class="form-group">
                <label class="col-md-2 control-label">E-mail</label>
                <div class="col-md-10">
                    <input class="form-control" id="email" type="text" placeholder="E-mail (requerido)" formControlName="email" [ngClass]="{'is-invalid': displayMessage.email }" />
                    <span class="text-danger" *ngIf="displayMessage.email">
                        <p [innerHTML]="displayMessage.email"></p>
                    </span>
                </div>
            </div>

            <div class="form-group">
                <label class="col-md-2 control-label">Senha</label>
                <div class="col-md-10">
                    <input class="form-control" id="senha" type="password" placeholder="Senha (requerido)" formControlName="senha" [ngClass]="{'is-invalid': displayMessage.senha }" />
                    <span class="text-danger" *ngIf="displayMessage.senha">
                        <p [innerHTML]="displayMessage.senha"></p>
                    </span>
                </div>
            </div>

            <div class="form-group">
                <label class="col-md-2 control-label">Confirme a Senha</label>
                <div class="col-md-10">
                    <input class="form-control" id="senhaConfirmacao" type="password" placeholder="Confirme a Senha (requerido)" formControlName="senhaConfirmacao" [ngClass]="{'is-invalid': displayMessage.senhaConfirmacao }" />
                    <span class="text-danger" *ngIf="displayMessage.senhaConfirmacao">
                        <p [innerHTML]="displayMessage.senhaConfirmacao"></p>
                    </span>
                </div>
            </div>
            <div class="form-group">
                <div class="col-md-4 col-md-offset-2">
                    <span><button class="btn btn-success" id="Registrar" [disabled]="!cadastroForm.valid" type="submit">Registrar</button></span>
                </div>
            </div>


            <div class="form-group">
                <div class="col-md-4 col-md-offset-2">
                    <p>Formulario valido: {{ cadastroForm.valid }}</p>
                    <p>Formulario Tocado: {{ cadastroForm.touched }}</p>
                    <p>Formulario Sujo: {{ cadastroForm.dirty }}</p><br>
                    <p>Formulario: {{ formResult }}</p>
                </div>
            </div>
        </div>
    </form>
</div>
--------------------------------------------------------------------------------------------------
5- Vinculando os FormControl com o HTML
formControlName="nome"

dentro da tag html de cada input deve ser vinculado essa tag(formControlName="nomeDoRespectivoCampo")

pois no .ts do componente esta assim

 ngOnInit() 
  {
    let nome = new FormControl('');
  }

  Mas para submter varios campos todos juntos, deve-se utlizar FormGroup no seu .ts e vincular dentro
  da tag form o FormGroup 

  ou seja no .ts, fica dessa forma:

  import { Component, OnInit } from '@angular/core';
import { FormControl, FormGroup } from '@angular/forms';

@Component({
  selector: 'app-cadastro',
  templateUrl: './cadastro.component.html'
})
export class CadastroComponent implements OnInit {

  cadastroForm: FormGroup; <=====================
  constructor() { 
  }
  ngOnInit() 
  {
    this.cadastroForm = new FormGroup({
      nome: new FormControl('') <=========================
    });
    
  }
}
 e no HTML fica assim 
 <form novalidate [formGroup]="cadastroForm" >

--------------------------------------------------------------------------------------------------
6- Para submeter um formulario pelo angular necessita , de um evento (ngSubmit) no template HTML
No Momento do submit voce consegue visualizar todos os dados do formulario 
 adicionarUsuario() {

    let x = this.cadastroForm.value;  <============ todos os dados do formulario estao aqui 
    console.log(x);
  }
--------------------------------------------------------------------------------------------------
7-Agora trablhando com FormBuilder, ao invés de usar dessa Forma aqui 

  ngOnInit() {
    this.cadastroForm = new FormGroup({
      nome: new FormControl(''),
      cpf: new FormControl(''),
      email: new FormControl(''),
      senha: new FormControl(''),
      senhaConfirmacao: new FormControl(''),
    });

Se injeta o FormBuilder no constructor dessa forma:
constructor(private fb: FormBuilder) {
  }

 ngOnInit() {
    this.cadastroForm = this.fb.group({
      nome: [''],
      cpf: [''],    <====== dai ele espera um array, dessa forma tambem pode incluir criterios de validação
      email: [''],
      senha: [''],
      senhaConfirmacao: ['']
    });
  } 
--------------------------------------------------------------------------------------------------
8- Criando um objeto da aplicação que ira representar os dados enviados do formulario

export interface Usuario {   <========= pode ser interface ou class se for class consegue habilitar algum tipo de comportamento, método etc
    id: string;
    nome: string;
    CPF: string;
    email: string;
    senha: string;
    senhaConfirmacao: string;
}
Inclui o objet no component.ts dessa forma 


  usuario: Usuario;

 e ao receber os dados do formulario e serializar no formato da interafce desejada faz isso
  adicionarUsuario() {
    this.usuario = Object.assign({},this.usuario,this.cadastroForm.value); <=======
    console.log(this.usuario);
  }
--------------------------------------------------------------------------------------------------
9- Validação Básica de Formulario ReactiveForms

Dentro do Component.ts 

this.cadastroForm = this.fb.group({
      nome: ['',Validators.required],
      cpf: ['',Validators.required],
      email: ['',Validators.required],
      senha: ['',Validators.required],
      senhaConfirmacao: ['',Validators.required]
    });
no template HTML tambem é possivel visualizar se o formulario esta com os dados validos 
<div class="form-group">
    <div class="col-md-4 col-md-offset-2">
        <p>Formulario valido: {{ cadastroForm.valid }}</p> <============= Dessa forma
    </div>
</div>

 e no template HTML dentro do proprio campo que vc deseja validar voce pode trabalhar da seguinte forma:
DESSA FORMA FICA SEMPRE EXIBIND A MENSAGEM
<div class="form-group">
    <label class="col-md-2 control-label" for="nome">Nome Completo</label>
    <div class="col-md-10">
        <input class="form-control" id="nome" type="text" placeholder="Nome (requerido)"
            formControlName="nome" />
        <span class="text-danger" *ngIf="cadastroForm.get('nome').errors">   <==== a diretive *ngIf verifica se o campo dentro do Form cadastroForm do campo nome possui algum erro
            <p>Preencha o Campo Nome </p>
        </span>
    </div>
</div>

EXISTEM VARIAS FORMAS UMA DELAS, É essa
<span class="text-danger" 
        <span class="text-danger" *ngIf="cadastroForm.get('nome').errors && (cadastroForm.get('nome').dirty || cadastroForm.get('nome').touched)"    <==============PRECISA HABILITAR ALGUMA LOGICA PARA APARECER (DESSA FORMA FUNCIONOU MELHOR)
        [hidden]="!cadastroForm.get('nome').touched || cadastroForm.get('nome').dirty"><==============PRECISA HABILITAR ALGUMA LOGICA PARA APARECER
        <p>Preencha o Campo Nome </p>
    </span>
</div>


OBS: por padrão o formulario ja sobe com erro 
cadastroForm.get('nome').errors <============= isso vai ser sempre true 

Podemos também embutir uma classe CSS no campo do formulario especifico com algum forma de validaçao,usando a diretvia [ngClass]

<div class="form-group">
    <label class="col-md-2 control-label" for="nome">Nome Completo</label>
    <div class="col-md-10">
        <input class="form-control" id="nome" 
        type="text" 
        placeholder="Nome (requerido)"

        [ngClass]="{'is-invalid': cadastroForm.get('nome').errors && (cadastroForm.get('nome').dirty || cadastroForm.get('nome').touched)}"    <=======ESSA AQUi
        
        formControlName="nome" />
        <span class="text-danger" 
        *ngIf="cadastroForm.get('nome').errors && (cadastroForm.get('nome').dirty || cadastroForm.get('nome').touched)">
            <p>Preencha o Campo Nome </p>
        </span>
    </div>
</div>

OBS: LEMBRANDO QUE A VALIDACAO ACIMA É POR CADA CAMPO
--------------------------------------------------------------------------------------------------
10- Fazendo uma validaçao pelo Bakend para bloquear os submits 

 <div class="form-group">
    <div class="col-md-4 col-md-offset-2">
        <span><button class="btn btn-success" 
            id="Registrar" 
            [disabled]="!cadastroForm.valid" <============ Dessa forma pelo HTML
            type="submit">Registrar</button></span>
    </div>
</div>


DESSA FORMA VALIDA PELO .TS BACKEND
 
 adicionarUsuario() {
    if(this.cadastroForm.dirty &&this.cadastroForm.valid ){ <====== verifica se o formulario esta sujo e se esta valido
      this.usuario = Object.assign({},this.usuario,this.cadastroForm.value);
      this.formResult = JSON.stringify(this.cadastroForm.value);
    }else{
      this.formResult ='Cadastro Invalido'
    }
 }
----------------------------------------------------------------------------------------------
11- Habiliando uma validação e validações especificas para cada erro 
é feito isso (adastroForm.get('email')?.errors?.email ) com uso do "?", pois aponta erros com nullable, entao se habilita esse modo unsafe
isso para ERROS ESPECIFICOS 

<div class="form-group">
<label class="col-md-2 control-label">E-mail</label>
<div class="col-md-10">
    <input class="form-control" id="email"
        type="text" 
        placeholder="E-mail (requerido)"
        [ngClass]="{'is-invalid': cadastroForm.get('email').errors && (cadastroForm.get('email').dirty || cadastroForm.get('email').touched)}"
        formControlName="email" />
    <span class="text-danger"
        *ngIf="cadastroForm.get('email')?.errors?.required && (cadastroForm.get('email').dirty || cadastroForm.get('email').touched)">
        <p>Preencha o Campo Email </p>
    </span>
    <span class="text-danger"
        *ngIf="cadastroForm.get('email')?.errors?.email && (cadastroForm.get('email').dirty || cadastroForm.get('email').touched)">
        <p>E-mail em formato invalido </p>
    </span>
</div>
</div>
----------------------------------------------------------------------------------------------
12 - Tentando instalar uma dependencia que deu muito problema, validação de CPF, pelo

npm i ng-brazil@2.0.9 <==== tem que ser nessa versao 

npm i ng2-validation <================== a versao esta na 4.2.0 só importei esse



ngOnInit() {
    this.cadastroForm = this.fb.group({
      nome: ['', Validators.required],
      cpf: ['', Validators.required],
      email: ['', [Validators.required, Validators.email]],
      senha: ['', [Validators.required, CustomValidators.rangeLength([6,15])]], <=== Validacao Customizada de senha 
      senhaConfirmacao: ['', Validators.required]
    });
  }

<div class="form-group">
    <label class="col-md-2 control-label">Senha</label>
    <div class="col-md-10">
        <input class="form-control" id="senha" type="password" placeholder="Senha (requerido)"
            formControlName="senha" />
        <span class="text-danger"
            *ngIf="cadastroForm.get('senha')?.errors?.rangeLength && (cadastroForm.get('senha').dirty || cadastroForm.get('senha').touched)">   <==== Essa validação funcionou
            <p>Tamanho Invalido</p>
        </span>
    </div>
</div>
----------------------------------------------------------------------------------------------
13 - Fazendo comparacao de Senha e senhaConfirmacao pelo BACKEND
 ngOnInit() {
    let senha = new FormControl('', [Validators.required, CustomValidators.rangeLength([6, 15])]);
    let senhaConfirmacao = new FormControl('', [Validators.required, CustomValidators.rangeLength([6, 15]), CustomValidators.equalTo(senha)]);


    this.cadastroForm = this.fb.group({
      nome: ['', Validators.required,Validators.minLength(2),Validators.maxLength(150)],
      cpf: ['', Validators.required,Validators.minLength(11),Validators.maxLength(11)],
      email: ['', [Validators.required, Validators.email]],
      senha: senha,
      senhaConfirmacao: senhaConfirmacao
    });
  }

  mas nao esta habilitando botao ainda, formulario ainda esta invalido

----------------------------------------------------------------------------------------------
13- Usando Observable para  ficar monitorando os campos do formulario.
No momento que tirar o foco do campo que ele vai informar se o campo esta errado ou não.

Nem sei o que falar Rever 

"Validações avançadas de formulario"
----------------------------------------------------------------------------------------------
14- Separando a aplicaçao em módulos, para que nao fique tudo somente registrado no app.module 
que é o módulo principal

  1-começando implementar módulo de navegação 
  2- criei dentro do contexto de Navegacao o NavegacaoModule que é um módulos secundário


Todo novo módulo, deve obrigatoriamente importar
import { NgModule } from "@angular/core";

----------------------------------------------------------------------------------------------
15 - Módulo de roteamento 

import { NgModule } from "@angular/core";
import { Routes, RouterModule } from '@angular/router';
     o app.route 

     iremos transformar o 
     export const rootRouterConfig: Routes = [
    { path: '', redirectTo: '/home', pathMatch: 'full'},
    { path: 'home', component: HomeComponent},
    { path: 'sobre', component: SobreComponent },
    { path: 'cadastro', component: CadastroComponent }
];

em um módulo segregado

Ficou assim:
---------------------------------
import { NgModule } from "@angular/core";// para ter um módulo
import { Routes, RouterModule } from '@angular/router';
import { HomeComponent } from './navegacao/home/home.component';
import { SobreComponent } from './institucional/sobre/sobre.component';
import { CadastroComponent } from './demos/reactiveForms/cadastro/cadastro.component';

export const rootRouterConfig: Routes = [
    { path: '', redirectTo: '/home', pathMatch: 'full' },
    { path: 'home', component: HomeComponent },
    { path: 'sobre', component: SobreComponent },
    { path: 'cadastro', component: CadastroComponent }
];


@NgModule({
    imports: [
        RouterModule.forRoot(rootRouterConfig)
    ],
    exports: [
        RouterModule
    ]
})
export class AppRoutingModule { }
---------------------------------
Dai remove do app.module (que é o módulo Principal) o 
  [RouterModule.forRoot(rootRouterConfig, { useHash: false })]
   e substitui por isso
   AppRoutingModule
----------------------------------------------------------------------------------------------
16- Lazy Loading de módulos .

criando componente dentro de demos 

ng g c demos/arquitetura-componentes/produto-dashboard

Por padrão ele ja injeta (ProdutoDashboardComponent) no módulo principal, (app.module), deve=se remover ele de la
Pois o que acontece, vc ja ira chamar esse Component dentro do Módulo produto.module.ts 

dentro desse novo componente, cria um módulo especifico e um de roteamento
dentro de  arquitetura-componentes

  1-produto.module.ts

  por padrao ja se importar
    
    import { NgModule } from "@angular/core";// para ter um módulo
    import { CommonModule } from "@angular/common";// para definir que esse não é o módulo principal 
    import { RouterModule } from "@angular/router"; //pq ele precisa ter um roteamento proprio

  2- produto.route.ts
    Por padrao ja se importar
      import { NgModule } from "@angular/core";// para ter um módulo
      import { Routes, RouterModule } from '@angular/router';

 
O bom do LazyLoading,e da segregação pe que ele funciona sozinho, não precisa ser injetado no app.module (Módulo Principal)
a unica coisa que vc faz após concluir o componente é referenciar a rota no app.route em formato lazyLoading,
dessa forma:


export const rootRouterConfig: Routes = [
    { path: '', redirectTo: '/home', pathMatch: 'full' },
    { path: 'home', component: HomeComponent },
    { path: 'sobre', component: SobreComponent },
    { path: 'cadastro', component: CadastroComponent },
    {
        path: 'produtos',
        loadChildren: () => import('./demos/arquitetura-componentes/produto.module')//dessa forma ativa o lazyLoading, para módulo externo
            .then(m => m.ProdutoModule)
    },
];
----------------------------------------------------------------------------------------------
17- Comunicação entre Componentes  Input Decorator

                     @Input 
    Componente Pai =================> Componente FIlho

                      @Output
    Componente Pai <================= Componente FIlho


    o padrao para cada novo compente filho
    import { Component, Input } from "@angular/core";
----------------------------------------------------------------------------------------------
18- Comunicação entre Component Filho para Componente Pai @Output

                      @Output
    Componente Pai <================= Componente FIlho

isso sempre ocorre no formato de eventos

Obs: Lembrand que esse evento vem do core e não do 'events'
import { Component, Input, Output,EventEmitter } from "@angular/core";
----------------------------------------------------------------------------------------------
19- Ng-content projection slots 

  customizar um item especifico dentro de um componente filho 
  tipo o mesmo componente esta sendo utilizado em diversos lugares, mas em um lugar especifico
  você deseja exibir uma informação diferente


  através da tag <ng-content></ng-content> que vc insere no componente filho 
  e dai dentro do componente pai entre as tags vc coloca o conteudo

  <produto-card-detalhe class="col-md-4" *ngFor="let produto of produtos" [produto]="produto"
            (status)="mudarStatus($event)">
            <h5>Ou vá até uma de  nossas lojas</h5>
        </produto-card-detalhe>

<produto-card-detalhe>
            <h5>Ou vá até uma de  nossas lojas</h5>   <==== coloca aqui dentro qualquer outra coisa
</produto-card-detalhe> <==== do componente filho


Dai por exemplo voce quer colocar mais mensagem porém ter um critério em qual momneto vc deve colocar
deve-se usar o selector

<ng-content select=".corre"></ng-content>
select=".corre" <========== vai atras dos elementos do componente pai que possuem essa classe


<produto-card-detalhe class="col-md-4" *ngFor="let produto of produtos" [produto]="produto"
            (status)="mudarStatus($event)">
            <h5 class="acabou"> Ou vá até uma de nossas lojas </h5>  <=======esse esta dentro do componente pai 
            <h5 class="corre"> Corre que vai acabar </h5> <=======esse esta dentro do componente pai 
</produto-card-detalhe>
----------------------------------------------------------------------------------------------
20- Interagir com eventos do HTML , por exemplo evento click 
obter uma coleção ou item através do Decorator @ViewChildren ou @ViewChild

Dentro do .html 

<h1 #teste>Lista Produtos</h1>

Dentro do componente.ts 

@ViewChild('teste', { static: false }) mensagemTela: ElementRef;

Porém deve ser tratada após a pagina ser renderizada

herda de  AfterViewInit

export class ProdutoDashboardComponent implements OnInit, AfterViewInit {

  o que força a implementação do 
  ngAfterViewInit(): void {
    throw new Error('Method not implemented.');
  }


é possivel fazer isso tambem com um componente Filho
no .ts do pai 

@ViewChild(ProdutoCountComponent, { static: false }) contador: ProdutoCountComponent;

@ViewChild ==> quando pega somente um elemento

@ViewChildren==> quando pegar  uma coleção de elementos


@ViewChildren(ProdutoDetalheComponent) botoes: QueryList<ProdutoDetalheComponent>;

----------------------------------------------------------------------------------------------
21 - Tratamento de erro 404 quando a rota nao leva a lugar algum, nenhum componente 
  
  Criando um novo componente 
          ng g c navegacao/notFound

dentro do app.module coloque dessa forma

export const rootRouterConfig: Routes = [
    { path: '', redirectTo: '/home', pathMatch: 'full' },
    
    { path: 'home', component: HomeComponent },
    { path: 'sobre', component: SobreComponent },
    { path: 'cadastro', component: CadastroComponent },
    {
        path: 'produtos',
        loadChildren: () => import('./demos/arquitetura-componentes/produto.module')//dessa forma ativa o lazyLoading, para módulo externo
            .then(m => m.ProdutoModule)
    },
    { path: '**', component:NotFoundComponent }// <==== essa configuracao tem que estar por ultimo, senao ela se sobrepoe as outras rotas
];          



----------------------------------------------------------------------------------------------
22- estilização de rota ativa
   Tipo no menu ou algum BreadCrumb


dentro do menu

se estier na rota selecionada routerLinkActive="active" fica em evidencia o link

<ul class="navbar-nav ml-auto">
      <li class="nav-item">
            <a class="nav-link" [routerLinkActiveOptions]="{ exact: true }" routerLinkActive="active" routerLinkActive="router-link-active"   [routerLink]="['/cadastro']">Cadastro</a>
      </li>
      <li class="nav-item">
            <a class="nav-link" [routerLinkActiveOptions]="{ exact: true }" routerLinkActive="active"  [routerLink]="['/sobre']">Sobre</a>
      </li>
      <li class="nav-item">
            <a class="nav-link" [routerLinkActiveOptions]="{ exact: true }"  routerLinkActive="active" [routerLink]="['/produtos']">Produtos</a>
      </li>
</ul>


se for uma rota variante, ou rota filha
<a class="nav-link" [routerLinkActiveOptions]="{ exact: false }" routerLinkActive="active"  [routerLink]="['/sobre']">Sobre</a>
----------------------------------------------------------------------------------------------
23 - Links de navegação dinamica ex: os links da barra de menu , montar dinamicamente

  Popule ou resgate algum objeto no componente.ts do menu.ts e preencha o html conforme esta no menu.html 


----------------------------------------------------------------------------------------------
24 - Rotas Filhas em Sub-Módulo 

  tipo navegando dentro do componente filho 
  /produtos/editar/323

  Criando um novo componente 

  
  
  
  ng g c demos/arquitetura-componentes/editarProduto




  O que acontece, temos no app.module (que é o modulo principal), esse provider

  providers: [
    { provide: APP_BASE_HREF, useValue: '/' }  
  ],

  ele define que tudo após seu dominio ele vai cuidar do redirecionamento, que trabalha junt com o 
  app.route, que tbm é o principal

  dentro do app.component.html ele possui essa tag
  
  <router-outlet></router-outlet> //que basicamente cuida de todos os roteamentos dentro da aplicação
  entao, para que tenha uma navegação interna através dos módulos e nao se perder na rota, deve-se definir O
  um novo componente principal para o módulo de produtos 

  produto.app.component.ts 

  ProdutoAppComponent, dessa forma:


import { Component } from '@angular/core';

@Component({
  selector: 'produto-app-root',
  template: '<router-outlet></router-outlet>'
})
export class ProdutoAppComponent {
  
}

E dentro do produto.route, definir ele como principal para rota vazia e o resto como se fosse seus filhos

const produtoRouterConfig: Routes = [
    {
        path: '', component: ProdutoAppComponent, children: [
            { path: '', component: ProdutoDashboardComponent },
            { path: 'editar/:id', component: EditarProdutoComponent }
        ]
    },
];

Cria-se um roteamento 100% autonomo. Ou seja modo mais correto de implementar




Ou simplesmente ir no index.html e colocar isso
<head>
  <base href="/">  <============

e remover do app.module, o APP_BASE_HREF
providers: [
    { provide: APP_BASE_HREF, useValue: '/' }
  ],
----------------------------------------------------------------------------------------------
25- Obtendo o Parametro da rota
 tipo, como pegar via queryString /editar/2



 private route: ActivatedRoute   <=== esse aqui que pega da rota .


 export class EditarProdutoComponent implements OnInit {
  produto : Produto;
  constructor(
    private route: ActivatedRoute,
    private produtoService: ProdutoService
  ) { }

  ngOnInit() {
    this.route.params
      .subscribe(params => {
        this.produto = this.produtoService.obterPorId(params['id']);
      });

  }

}
----------------------------------------------------------------------------------------------
26 - Navegação Imperativa com Router API 

precisa injetar a bibilioteca Router 
import { ActivatedRoute, Router } from '@angular/router';

 constructor(
    private route: ActivatedRoute,
    private produtoService: ProdutoService,
    private router: Router <==============
  ) { }



 salvar() {
    //fazer coomunicação com backend
    this.router.navigate(['/produtos',2]);//pode colocar virgula e um Parametro 
  }

  Existem 2 metodos o this.router.navigateByUrl

  this.router.navigateByUrl('/produtos'); // Como se tivesse colocando a url manualmente e dando um enter 

  pelo this.router.navigate voce nao sente ele mudar de pagina, se usar o  navigateByUrl, parece que ao 
  mudar ele da um refresh na tela
----------------------------------------------------------------------------------------------
  27 - Route Tracing saber em qual rota ele ta passando sem ficar enchendo de console.log 

  dentro do app.route, adicione a flag { enableTracing: true }

  @NgModule({
    imports: [
        RouterModule.forRoot(rootRouterConfig, { enableTracing: true }) //não use em produção como true, apenas para inspeção
    ],

    salvo uma imagem de como fica na inspeção (27 -Route Tracing Inspeção.png)
----------------------------------------------------------------------------------------------
28 - Route Resolves and Snapshots

por exemplo temos uma rota de edição

http://localhost:4200/produtos/editar/1   <===== queremos pegar o 1, sem o Router 

 this.route.params
      .subscribe(params => {  <=== Router 
        params['id']
      });

Tipo querendo fazer um filtro com base em algum tipo de pesquisa
Exemplo:

http://localhost:4200/produtos/ativos

http://localhost:4200/produtos/inativos

http://localhost:4200/produtos/expirados



no router do modulo que vc deseja filtrar pelo estado

const produtoRouterConfig: Routes = [
    {
        path: '', component: ProdutoAppComponent, children: [
            { path: '', redirectTo:'todos'  },
            { path: ':estado', component: ProdutoDashboardComponent }, <==== inclua ele na rota :estado
            { path: 'editar/:id', component: EditarProdutoComponent }
        ]
    },
];

Feito isso cria-se o resolve que é um serviço, que será injetado, deve-se herdar de Resolve<T>
cujo tipo no caso é o objeto que vc deseja filtrar , no caso é o Produto 
ele pede que vc implemente esse método que pode ter 3 tipos diferentes de retorno 

1- Produto 
2- Observable<Produto>
3- Promise<Produto>

@Injectable()
export class ProdutoResolve  implements Resolve<Produto> {
    
    resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Produto | Observable<Produto> | Promise<Produto> {
        throw new Error("Method not implemented.");
    }

}

Porém pode deixar mais simples a implementação

@Injectable()
export class ProdutoResolve  implements Resolve<Produto[]> {
    constructor(private produtoService: ProdutoService){
    }

    resolve(route: ActivatedRouteSnapshot) {
        return this.produtoService.obterTodos(route.params.estado);
    }

}

o  route.params.estado você pega do produto.router.ts 

const produtoRouterConfig: Routes = [
    {
        path: '', component: ProdutoAppComponent, children: [
            { path: '', redirectTo:'todos'  },
            { path: ':estado', component: ProdutoDashboardComponent }, <==== pego daqui
            { path: 'editar/:id', component: EditarProdutoComponent }
        ]
    },
];

e dai vc altera a rota assim:

const produtoRouterConfig: Routes = [
    {
        path: '', component: ProdutoAppComponent, children: [
            { path: '', redirectTo: 'todos' },
            {
                path: ':estado',
                component: ProdutoDashboardComponent,
                resolve: {
                    produtos: ProdutoResolve <=========o Resolve que acabou de ser criado
                }
            },
            { path: 'editar/:id', component: EditarProdutoComponent }
        ]
    },
];


no caso no componente que vc alimenta fuca assim, no caso é o produto-dashboard.component.ts

  this.route.snapshot.data o "data" é o dado da rota 

  this.route => rota ativa ActivatedRoute
  snapshot => estado atual 
  data => dado da rota 

  constructor(private route: ActivatedRoute) { }
  ngOnInit() {
    this.produtos = this.route.snapshot.data['produtos'];
  }

Conclusao: ao invès de usar o backend, voce faz esse tipo de requisiçao pela propria rota 


1- cvriar um resolve
2- passar o serviço que vai usar para obter os dados 
3- registrar o resolve como um serviço dentro do respectivo módulo 
4- na rota vc diz que esta trabalhando com resolve 
5- dentro do component vc diz que esta usando snapshot da rota ativa 
----------------------------------------------------------------------------------------------
29 - Obter e armazenar dados na rota 

  no arquivo de rota vc pode trabalhar com mais um marcador chamado "data"
  const produtoRouterConfig: Routes = [
    {
        path: '', component: ProdutoAppComponent, children: [
            { path: '', redirectTo: 'todos' },
            {
                path: ':estado',
                component: ProdutoDashboardComponent,
                resolve: {
                    produtos: ProdutoResolve
                },
                data: {                     <================== Esse aqui
                    teste: 'informacao'
                }
            },
            { path: 'editar/:id', component: EditarProdutoComponent }
        ]
    },
];


dentro do componente que vc usou o snaphot

constructor(private route: ActivatedRoute) { }
  ngOnInit() {
    this.produtos = this.route.snapshot.data['produtos'];
    console.log(this.route.snapshot.data['teste']); < ============================= aqui aparece informacao, pode usar como forma de filtrar permissoes
  }


Conclusao: Voce usa o Resolve item 28, para colocar dados dentro da rota , ou você pode de maneira 
direta ja enfiar dados dentro da rota usando o marcador "data"
----------------------------------------------------------------------------------------------
30- Route Guard o guarda da rota 

Rotas com certos perfis podem acessar

Criando um componente de Admin, e configurando para ser um módulo independente, com modulo e roteamento proprio 

ng g c admin/admin-dashboard


lembrando de deletar o app.module e somente ser carregado pelo lazyLoading, do app.route 


Dentro da app.route, implementa um novo atributo o "canLoad" 

export const rootRouterConfig: Routes = [
    { path: '', redirectTo: '/home', pathMatch: 'full' },

    { path: 'home', component: HomeComponent },
    { path: 'sobre', component: SobreComponent },
    { path: 'cadastro', component: CadastroComponent },
    {
        path: 'produtos',
        loadChildren: () => import('./demos/arquitetura-componentes/produto.module')//dessa forma ativa o lazyLoading, para módulo externo
            .then(m => m.ProdutoModule)
    },
    {
        path: 'admin',
        loadChildren: () => import('./admin/admin.module')
            .then(m => m.AdminModule),
            canLoad:[] <=============================================Esse atributo aqui
    },
    { path: '**', component: NotFoundComponent }// <==== essa configuracao tem que estar por ultimo, senao ela se sobrepoe as outras rotas
];

cria-se um novo serviço de guarda que implementa o CanLoad,no momento que tenta herdar ele já força uma implementação
com um método enorme, não precisa de nada disso, pode estar vazio os parametros

@Injectable()
export class AuthGuard  implements CanLoad {
    canLoad(route: Route, segments: UrlSegment[]): boolean | Observable<boolean> | Promise<boolean> {
        throw new Error("Method not implemented.");
    } 
}


Pode fica assim:

canLoad() {
        throw new Error("Method not implemented.");
    } 

Dai comunica ou injeta algum outro serviço que valida se o usuario tem perfil ou não

@Injectable()
export class AuthGuard implements CanLoad {

    user = { admin: false, logged: false }

    canLoad() {
        return this.user.admin;
    }
}

E no app.route 

export const rootRouterConfig: Routes = [
    { path: '', redirectTo: '/home', pathMatch: 'full' },

    { path: 'home', component: HomeComponent },
    { path: 'sobre', component: SobreComponent },
    { path: 'cadastro', component: CadastroComponent },
    {
        path: 'produtos',
        loadChildren: () => import('./demos/arquitetura-componentes/produto.module')//dessa forma ativa o lazyLoading, para módulo externo
            .then(m => m.ProdutoModule)
    },
    {
        path: 'admin',
        loadChildren: () => import('./admin/admin.module')
            .then(m => m.AdminModule),
            canLoad:[AuthGuard] <======================================Esse atributo aqui que retorna um true ou false 
    },
    { path: '**', component: NotFoundComponent }// <==== essa configuracao tem que estar por ultimo, senao ela se sobrepoe as outras rotas
];


Existe mais um passo de verificação para ver se ele baixa o  módulo que é o canActivate

export const rootRouterConfig: Routes = [
    { path: '', redirectTo: '/home', pathMatch: 'full' },

    { path: 'home', component: HomeComponent },
    { path: 'sobre', component: SobreComponent },
    { path: 'cadastro', component: CadastroComponent },
    {
        path: 'produtos',
        loadChildren: () => import('./demos/arquitetura-componentes/produto.module')//dessa forma ativa o lazyLoading, para módulo externo
            .then(m => m.ProdutoModule)
    },
    {
        path: 'admin',
        loadChildren: () => import('./admin/admin.module')
            .then(m => m.AdminModule),
            canLoad: [AuthGuard], canActivate: [AuthGuard] <==== que tbm faz uso de um Guard 
    },
    { path: '**', component: NotFoundComponent }// <==== essa configuracao tem que estar por ultimo, senao ela se sobrepoe as outras rotas
];

o canActivate pode ser colocado em qualquer tipo de componente seja ele LazyLoading ou nao 

Exemplo:

{ path: 'sobre', component: SobreComponent , canActivate: [AuthGuard]},


O canLoad, só pode ser utilizado quando se usa o LazyLoading
----------------------------------------------------------------------------------------------
31 - Route canDeactive Guard 
     Faz o contrario do anterior, impede que vc saia da rota 

     Imaginamos que vc esteja em um cadastro, vc nao pode sair dele caso algum criterio, nao esteja
     sendo obedecido 
